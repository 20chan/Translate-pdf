# Why Functional Programming Matters

> John Hughes 저

## Abstract

소프트웨어가 더 편해질수록, 이를 잘 구조화하는것도 중요해진다. 잘 구조된 소프트웨어는 작성하기도 쉽고, 디버깅하기도 쉽고, 미래의 프로그래밍 비용을 줄여줄 재사용가능한 모듈들을 제공한다. 기존의 언어들은 문제를 모듈화 하는 방법에 제한을 정했다. 하지만 함수형 언어들은 이러한 한계를 되돌린다. 여기서 우리는 함수형 언어 두 기능, 고차함수와 게으른 게산이 모듈화에 매우 효과적이라는걸 보여줄 것이다. 예를 들어, 우리는 리스트와 트리를 다루고 몇몇 수치 알고리즘을 구현하고 알파-베타 휴리스틱 (게임에 사용되는 AI 알고리즘)을 구현할 것이다. 모듈화가 성공적인 프로그래밍의 핵심이기 때문에 함수형 언어는 현실 세계에서 매우 중요합니다.

## 1. Introduction

여기서는 함수형 프로그래밍이 현실 세계에 매우 중요함을 보여주고 함수형 프로그래밍의 장점이 뭔지 확실하게 하려 한다.

함수형 프로그래밍을 그렇게 부르는 이유는 프로그램 전체가 함수로 구성되기 때문이다. 메인 프로그램은 프로그램의 인풋을 매개변수로 받고 프로그램의 결과를 리턴값으로 반환하는 함수이다. 일반적으로 메인 함수는 다른 함수들로 구성이 되어 있고 또 그 함수들은 다른 많은 함수들로 구성이 되어 있고 이는 언어 차원의 함수 레벨로 내려갈때 까지 계속된다. 이 함수들은 일반적으로 수학에서의 함수와 매우 비슷하고 여기서는 일반적인 식의 형태로 정의할 것이다. 우리는 Turner의 언어 `Miranda`를 사용하지만 함수형 언어들에 대한 별 지식이 없어도 읽을 수 있다.

함수형 프로그래밍의 특별한 점과 이점은 자주 다음으로 요약된다. 함수형 프로그램은 변수 선언이 없고, 따라서 당연히 변수도 없고, 모든 값은 불변성을 가진다. 다시말해, 함수형 프로그램은 부작용이 없다. 함수 호출은 결과값을 계산하고 다른 것들에 아무 영향이 없다. 이것은 대부분의 버그의 원인을 차단하고, 또한 실행 순서를 중요하지 않게 만든다. 즉, 식의 값을 변경하는 부작용이 없으니 언제든지 계산되어도 괜찮다는 소리이다. 이건 코드 플로우에 머리가 터지는 프로그래머들에게 부담을 덜어준다. 식이 언제든지 계산될 수 있다는 것은 어떤 값이든 변수로 나타낼 수 있고, 그 반대도 가능하며, 이를 '참조적으로 투명하다'라고 한다. 이 자유로움은 다른 전통적인 언어보다 함수형 프로그램을 더 수학적으로 다룰 수 있게 해준다.

이 장점들은 모두 매우 훌륭하지만, 다른 사람들이 심각하게 받아들이지 않는다면 그렇게 놀랄만한 것들은 아니다. 이는 무엇이 함수형 프로그래밍이 아니냐(선언 X, 부작용 X, 코드 플로우 X)고는 알려주지만, 이게 뭔지는 알려주지 않는다. 함수형 프로그래머는 마치 고결해지기 위해 삶의 재미를 포기하는 수도승처럼 들린다. 물질적 이득에 관심이 있는 사람들에게는 이 장점들이 설득적이지 못한다.

함수형 프로그래머들은 굉장한 물질적 이득이 있다고 한다-함수형 프로그래머는 코드의 양이 적기 때문에 전통적인 언어보다 생산적이라고 한다. 왜 그래야 하나? 이러한 장점에 근거하여 낼 수 있는 유일한 그럴듯한 이유는 기존의 언어의 90%가 선언문으로 이루어져 있고 함수형 프로그램에선 이게 없기 때문이다! 이건 분명히 어이없다. 선언 문들을 없애는게 엄청난 혜택을 가져온다면 포트란 프로그래머는 20년전부터 그랬겠지. 기능을 뺌으로써 언어가 강력해지는건 말도 안된다. 그 기능이 얼마나 나쁜지와 관계 없이 말이다.

이 장점이라 불리는 것들에 함수형 프로그래머들은 만족하지 않아야 한다. 이는 함수형 언어를 활용하는데 전혀 도움이 되지 않기 때문이다. 선언 없이, 혹은 참조 투명하다는걸로는 프로그램을 작성할 수 없다. 거기에는 프로그램의 퀄리티를 따질 척도가 없고, 지향할 목표도 없다.

분명히 이 함수형 프로그래밍의 특징들로는 충분하지 않다. 우리는 여기에 넣을 뭔가를 찾아야 한다 - 함수형 프로그래밍의 힘을 설명하는 것만이 아닌것을, 하지만 또한 함수형 프로그래머가 무엇을 지향해야 할지 정확한 목표가 될 것을.

## 2. 구조적 프로그래밍의 비교

함수형이고 구조화된 프로그래밍을 비교하는 것은 도움이 된다. 과거에는, 구조적 프로그래밍의 특성과 장점은 다음으로 요약이 됬다. 구조적 프로그래밍은 `goto`문이 없다. 구조적 프로그램의 블록들은 여러개의 진입점이나 종료점이 없다. 구조적 프로그램들은 구조화되지 않은 기존의 프로그램들보다 수학적이다. 이 구조적 프로그래밍의 장점들은 우리가 좀전에 얘기했던 함수형 프로그래밍의 장점과 매우 닮아 있다. 이것들은 부정적인 것들이며 본질적인 `goto`과 관련된 무의미한 논쟁들만 가져온다.

되돌아보면, 이 구조적 프로그램의 속성들이 도움이 됬지만 문제의 핵심에는 별 도움을 주지 않는다. 가장 중요한 구조적 프로그램과 비구조적 프로그램의 차이는 구조적 프로그램은 모듈적 설계된다는 것이다. 모듈적 설계는 매우 생산적 발전을 가져온다. 가장 먼저, 작은 모듈은 빠르고 쉽게 코딩된다. 두번째로, 일반화된 모듈을 재사용될 수 있고 다음 프로그램을 빠르게 개발할 수 있다. 세번째로, 프로그램의 모듈은 독립적으로 테스트될 수 있어 디버깅 시간을 줄일 수 있다.

goto가 없는거랑 이거랑은 연관이 별로 없다. 이건 소규모 프로그래밍에 도움이 되고, 모듈  방식으로 디자인하는 건 대규모 프로그래밍에 도움이 된다. 그래서 누구나 조금만 작업을 해도 포트란이나 어셈블리어에서 구조적 프로그래밍을 하는 재미를 볼 수 있다.

모듈적 설계는 이제 성공적인 프로그래밍이 되는 키로 보통 인식되고, `Modula-II`나 `Ada`, 그리고 `Standard ML`같은 더 나은 모듈화를 돕도록 설계된 특별한 기능들을 포함하고 있다. 반면에, 가장 중요한 점 하나가 빠져 있다. 문제를 해결하러 모듈화된 프로그램을 작성할 때, 하나의 문제를 여러개의 문제로 나누고 나눠진 문제들을 해결한 다음 각 해결책을 하나로 합친다. 원래의 문제를 나누는 것은 해결책들을 다시 합치는 것에 달려 있다. 따라서, 문제를 잘 모듈화하여 각 능력을 높이려면, 프로그래밍 언어 차원에서 `접착제`를 제공해야 한다. 복잡한 스코프 규칙이나 분할 컴파일 방법은 저수준에만 도움이 되고 모듈화에 도움을 주는 툴을 제공하지 않는다.

이제 우리는 다시 함수형 프로그래밍으로 돌아와보자. 우리는 함수형 언어가 우리에게 제공하는 두가지, 매우 중요한 `접착제`에 대해 얘기해 볼 것이다. 우리는 매우 간단하고 쉽게 모듈화되는 많은 프로그램의 예제를 볼 것 이다. 이것이 함수형 프로그래밍의 강력함의 핵심이다 - 강력한 모듈화를 제공한다. 또한 이건 함수형 프로그래머가 지향해야 하는 목표이다 - 더 작고 더 간단한 많은 일반적인 모듈이 우리가 곧 설명할 `접착제`로 결합되는 것이다.

## 3. 함수 결합하기

간단한 함수를 서로 결합시켜서 더 복잡한 함수로 만들어주는 두 새로운 `접착제`의 첫번째이다. 이건 리스트에 원소를 더하는 간단한 리스트 처리 문제로 설명할 수 있다. 우리는 리스트를 다음과 같이 정의할 수 있다. (X는 특정한 기호가 아닌, *같은 의미)

```
listof X ::= nil | cons X (listof X)
```

리스트의 원소가 없을때인 X가 `nil`일 때이거나 다른 리스트에 X의 `cons`이다.  `cons`는 첫번째 원소가 X이고 나머지 원소들은 다른 원소들로 이루어진 리스트라고 할 수 있는 리스트를 나타낸다. 여기서의 X는 어떤 타입이든 될 수 있다. 예를 들어 X가 정수라면 이 정의는 정수의 리스트는 비어있는 리스트이거나 한 정수와 나머지 정수의 리스트의 `cons`이라는 것이다. 다음의 간단한 연습으로 우리는 리스트를 `nil`과 `cons`들로 일일히 쓰지 않고 대괄호로 원소들을 감싸서 간단하게 쓸것이다. 이건 노테이션의 편의를 위함일 뿐이다. 예를 들어,

```
[]			means nil
[1]			means cons 1 nil
[1,2,3]		means cons 1 (cons 2 (cons 3 nil))
```

리스트의 원소들은 재귀적 함수 `sum`으로 추가될 수 있다. `sum`은 두 종류의 매개변수로 정의되어야만 한다 : 빈 리스트 `nil`, 그리고 `cons`이다. 리스트가 비었을 때 합은 0이므로, 우리는 이를

```
sum nil = 0
```

로 정의하고, `cons`의 첫번째 원소와 나머지의 `sum`의 합으로 계산할 수 있으므로 우리는 이를

```
sum (cons num list) = num + sum list
```

로 정의할 수 있다. 이 정의를 살펴보면, 우리는 아래 박스 부분만 합을 계산하는 부분이라는 것을 알 수 있다.

```
          +---+
sum nil = | 0 |
          +---+
                          +---+
sum (cons num list) = num | + | sum list
                          +---+
```

이것은 합의 계산이 박스 부분을 재귀적 패턴으로 결합해서 모듈화될 수 있음을 보여준다. 이 재귀적 패턴은 보통 `reduce`라고 불리며 합은 다음과 같이

```
sum = reduce add 0
```

로 나타낼 수 있고, 편의를 위해 `reduce`는 연산자 대신 함수 `add`를 포함한 두 매개변수를 넘겨받는다. 함수 `add`는 단순하게 다음과 같이 정의된다.

```
add x y = x + y
```

`reduce`의 정의는 `sum`의 정의를 인수화 함으로써 나타낼 수 있다.

```
(reduce f x) nil = x
(reduce f x) (cons a l) = f a ((reduce f x) l)
```

우리는 `reduce f x`을 괄호로 둘러싸서 이게 `sum`을 대체함을 분명히 하였다. 보통 괄호는 생략하여 표기하므로 `((reduce f x) l)`은 `(reduce f x l)`로 나타낼 수 있다. `reduce`와 같이 세개의 인자를 받는 함수는 두개의 인자를 받고 나머지 한개의 인자를 받는 함수를 리턴한다. 보통, n개의 인자를 받는 함수가 n보다 작은 m개의 인자를 받는다면, 이 값은 나머지 n - m개의 인자를 받는 함수가 될 것이다. 우리는 이 것을 나중에 볼 것이다.

이 방법으로 합 구하기를 모듈화 함으로써 우리는 각 파트들을 재사용하는 이득을 얻을 수 있었다. 가장 흥미로운 부분은 `reduce`이다. 이것을 사용해 우리는 더 프로그램을 작성할 필요 없이 리스트의 각 원소를 곱하는 함수를 작성할 수 있다.

```
product = reduce multiply 1
```

또한 우리는 리스트에서 참인 원소가 존재하는지 확인하는 코드를 짤 수도 있고

```
anytrue = reduce or false
```

모두가 참인지 확인하는 코드도 짤 수 있다.

````
alltrue = reduce and true
````

`(reduce f a)`는 list에 있는 모든 cons들을 f로 대체하고 nil을 a로 대체하는 것이다. 예를 들어, 리스트 `[1, 2, 3]`는

```
cons 1 (cons 2 (cons 3 nil))
```

이고, `(reduce add 0)`은 이것을 다음과 같이 바꾼다.

```
add 1 (add 2 (add 3 0)) = 6
```

그리고 `(reduce multiply 1)`은 다음과 같이 바뀐다.

```
multiply 1 (multiply 2 (multiply 3 1)) = 6
```

그렇다면 이제 `(reduce cons nil)`은 리스트를 단순히 복사한다는 것은 당연하다. 한 리스트의 맨앞에 원소를 `cons`함으로써 리스트에 값이 추가됨을 앎으로써, 우리는

```
append a b = reduce cons b a
```

를 알아낼 수 있다. 예를 들어,

```
append [1,2] [3,4] = reduce cons [3,4] [1,2]
                   = (reduce cons [3,4]) (cons 1 (cons 2 nil))
                   = cons 1 (cons 2 [3,4]) 
                        (replacing cons by cons and nil by [3,4])
                   = [1,2,3,4]
```

모든 원소를 두배로 만드는 함수는 다음과 같이 작성할 수 있다.

```
      doubleall = reduce doubleandcons nil
where doubleandcons num list = cons (2*num) list
```

함수 `doubleandcons`는 좀 더 모듈화할 수도 있다. 먼저

```
      doubleandcons = fandcons double
where double n = 2*n
      fandcons f el list = cons (f el) list
```

그리고 이는

```
fandcons f = cons . f
```

로 함수를 합성하는 연산자 `.`로 나타낼 수 있고, 이 연산자는 

```
(f . g) h = f (g h)
```

로 정의된다. 우리는 `fandcons`의 새로운 정의가 몇 인자를 줌으로써 맞는지 확인할 수 있다:

```
   fandcons f el = (cons . f) el
                 = cons (f el)
so fandcons f el list = cons (f el) list
```

최종 버젼은 다음과 같다.

```
doubleall = reduce (cons . double) nil
```

한단계 더 모듈화를 하면 우리는

```
doubleall = map double
map f = reduce (cons . f) nil
```

와 같이 어떤 함수 f를 리스트의 모든 원소에 적용하는 함수 `map`을 사용하여 나타낼 수 있다. 함수 `map`도 자주 쓰이는 유용한 함수이다.

심지어 우리는 리스트들의 리스트인 행렬의 모든 원소를 더하는 함수를 작성할 수도 있다.

```
summatrix = sum . map sum
```

`map sum`은 `sum`을 가로 행값을 전부 더하는데 사용하고, 가장 왼쪽의 `sum`은 가로 행의 결과값을 더해 전체 매트릭스의 합을 구해낸다.

이러한 예제들은 작은 모듈화로도 큰 변화를 가질 수 있음을 보여준다. 간단한 함수 `(sum)`을 고차 함수들과 인자들의 조합으로 모듈화함으로써 우리는 `(reduce)`이라고 하는 추가적인 노력 없이 많은 리스트를 다루는 함수들에 사용되는 파트에 도달할 수 있었다. 우리는 리스트를 다루는 함수에서 멈춰서는 안된다. 다른 예제로, 다음과 같이 정의되는 트리 자료형에 대해 알아보자.

```
treeof X ::= node X (listof (treeof X))
```

이 정의는 X들의 트리가 X라는 라벨을 가진 노드이고, 하위 트리들은 또 X의 트리들을 가짐을 보여준다. 예를 들어, 다음과 같은 트리

```
1 -- 3 -- 4
 \---2
```

는

```
node 1
    (cons (node 2 nil)
          (cons (node 3
                      (cons (node 4 nil) nil))
                nil))
```

로 나타낼 수 있다. 예를 들거나 고차 함수를 추상화하는 대신, 우리는 `reduce`와 비슷한 함수 `redtree (reduce tree)`를 바로 만들어 볼 것이다. `reduce`가 두개의 인자를 받는다는 것을 기억하자. `cons`를 대체할 무언가와 `nil`을 대체할 무언가 말이다. 트리가 노드, `cons`, `nil`로 이루어진다는 걸 볼때, `redtree`는 세개의 인자를 받아야 한다 - 각각을 대체할 것들 말이다. 트리와 리스트가 매우 다른 타입임을 볼 때, 우리는 두개의 함수를 정의할 것이다.
```
redtree f g a (node label subtrees) = 
        f label (redtree' f g a subtrees)
redtree' f g a (cons subrtree rest) = 
        g (redtree f g a subtree) (redtree' f g a rest)
redtree' f g a nil = a
```
많은 흥미로운 함수가 `redtree`와 다른 함수를 함께 결합함으로써 정의될 수 있다. 예를 들어, 트리의 라벨인 숫자들은 다음을 이용하여 전부 더해질 수 있다.
```
sumtree = redtree add add 0
```
방금 썼던 예제에 `sumtree`를 사용하면 다음과 같은 결과가 나온다.
```
add 1
    (add (add 2 0)
         (add (add 3
                   (add (add 4 0) 0))
              0))
= 10
```
트리의 모든 라벨의 리스트는 다음으로 게산될 수 있다.
```
labels = redtree cons append nil
```
같은 예제를 사용하면,
```
cons 1
     (append (cons 2 nil)
             (append (cons 3
                           (append (cons 4 nil) nil))
                     nil))
= [1,2,3,4]
```
마지막으로, `map`과 비슷하게 트리의 모든 라벨에 함수 `f`를 적용시키는 함수는 다음과 같이 정의된다.
```
maptree f = redtree (node . f) cons nil
```
이 모든것은 함수형 언어가 기존의 언어에서는 되지 않는 고차 함수와 구체화 함수들의 결합을 허용했기 때문에 이뤄질 수 있다. 이러한 고차 함수가 정의되면 많은 작업들이 매우 쉽게 할 수 있다. 새로운 데이터 타입이 정의될 때마다 이를 처리하는 고차함수도 작성되어야 한다. 이것은 데이터 타입을 쉽게 다룰 수 있게 해주고, 또한 이것의 자세한 세부적인 부분들을 잘 알 수 있게 해준다. 기존의 프로그래밍과 가장 비교되는 부분은 이 확장가능한 언어이다. 이것은 프로그래밍 언어가 언제든지 새로운 제어구조로 확장 가능하다는 것이다.

## 4. 프로그램 결합하기

함수형 언어가 제공하는 새로운 종류의 `접착제`는 전체 프로그램을 서로 결합가능하게끔 해준다. 전체 함수형 프로그램이 단순히 입력과 출력을 가지는 함수라는 것을 기억하자. 만약 f와 g가 그러한 프로그램이라면 `(g . f)`는 입력을 받으면 다음을 계산하는 프로그램이다.
```
g (f input)
```
프로그램 `f`의 출력은 프로그램 `g`의 입력으로 사용된다. 전통적인 방식으로는, `f`의 출력을 임시적으로 저장하는 것으로 해결되었다. 문제는 프로그램을 이 방식대로 결합하기에는 임시적으로 저장된 파일이 메모리를 너무 차지하는 것이다. 함수형 언어에서는 이 문제에 해결책을 제공한다. 두 프로그램 `f`와 `g`는 엄격한 동기화상태에서 동시에 실행된다. `f`는 `g`가 입력이 필요할 때에만 실행되고 `g`가 받으려 하는 것까지만 출력을 전달할때까지 실행된다. 그런 뒤에 `f`는 멈추고 `g`는 다른 입력을 받을때까지 실행된다. 그 뒤로 만약 `g`가 `f`의 모든 결과값을 필요로 하지 않고 종료된다면 `f`는 종료된다. 심지어 `f`는 무한한 양의 결과값을 가지는 종료되지 않는 프로그램일 수도 있다. 하지만 그래도 `g`가 종료된다면 강제적으로 종료될 것이다. 이것은 반복하는 구간에서 종료 조건을 없애도록 하여 강력한 모듈화를 제공한다.
`f`를 가능한 최소화해서 실행하는 것을 `lazy evaluation`이라고 부른다. 이것은 프로그램을 많은 가능한 답들을 구성하는 제너레이터와 적당한 하나를 고르는 셀렉터로 모듈화하는데 실용적이다. 이런 방법을 사용하여 프로그램을 함께 실행하는 다른 시스템들도 있지만, 오직 함수형 언어만이 `lazy evaluation`으로 모든 함수의 호출에 사용되 프로그램의 모든 파트를 모듈화하게끔 해준다. `lazy evaluation`은 아마 함수형 프로그래머의 레퍼토리에서 가장 강력한 모듈화 도구일 것이다.

### 4.1 뉴턴-랩슨법

> 편의상 여기서부터 `lazy evaluation`을 지연 평가라고 번역하겠음
우리는 지연 평가의 강력함을 몇몇 수치 알고리즘을 구현해보고 알아볼 것이다. 가장 먼저, 뉴튼-랩슨 알고리즘이 제곱근을 찾는 알고리즘이라는 것을 알고 시작하자. 이 알고리즘은 수 N의 제곱근을 초기 근사값 a0부터 시작해서 다음 규칙을 사용해 점점 정확하게 찾는다.
```
a(n+1) = (a(n) + N/a(n)) / 2
```
만약 추정값이 a로 수렴한다면, 
```
a = (a + N/a) / 2
2a = a + N/a
a = N/a
a*a = N
a = squareroot(N)
```
실제로 값은 매우 빠르게 수렴한다. 제곱근 프로그램은 주어진 허용 오차를 가지고 추정값의 차이가 허용 오차보다 작아지면 멈춘다.
이 알고리즘은 다음과 같이 자주 쓰인다:
```
C   N IS CALLED ZN HERE SO THAT IT HAS THE RIGHT TYPE
      X = A0
      Y = A0 + 2. * EPS
C   Y'S VALUE DOES NOT MATTER SO LONG AS ABS(X-Y).GT.EPS
100   IF ABS(X-Y).LE.EPS GOTO 200
      Y = X
      X = (X + ZN/X) / 2.
      GOTO 100
200   CONTINUE
C   THE SQUARE ROOT OF ZN IS NOW IN X.
```
이 프로그램은 기존의 언어에서는 나누어 떨어지지 않는다. 우리는 