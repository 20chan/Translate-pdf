# Why Functional Programming Matters

> John Hughes 저

## Abstract

소프트웨어가 더 편해질수록, 이를 잘 구조화하는것도 중요해진다. 잘 구조된 소프트웨어는 작성하기도 쉽고, 디버깅하기도 쉽고, 미래의 프로그래밍 비용을 줄여줄 재사용가능한 모듈들을 제공한다. 기존의 언어들은 문제를 모듈화 하는 방법에 제한을 정했다. 하지만 함수형 언어들은 이러한 한계를 되돌린다. 여기서 우리는 함수형 언어 두 기능, 고차함수와 게으른 게산이 모듈화에 매우 효과적이라는걸 보여줄 것이다. 예를 들어, 우리는 리스트와 트리를 다루고 몇몇 수치 알고리즘을 구현하고 알파-베타 휴리스틱 (게임에 사용되는 AI 알고리즘)을 구현할 것이다. 모듈화가 성공적인 프로그래밍의 핵심이기 때문에 함수형 언어는 현실 세계에서 매우 중요합니다.

## 1. Introduction

여기서는 함수형 프로그래밍이 현실 세계에 매우 중요함을 보여주고 함수형 프로그래밍의 장점이 뭔지 확실하게 하려 한다.

함수형 프로그래밍을 그렇게 부르는 이유는 프로그램 전체가 함수로 구성되기 때문이다. 메인 프로그램은 프로그램의 인풋을 매개변수로 받고 프로그램의 결과를 리턴값으로 반환하는 함수이다. 일반적으로 메인 함수는 다른 함수들로 구성이 되어 있고 또 그 함수들은 다른 많은 함수들로 구성이 되어 있고 이는 언어 차원의 함수 레벨로 내려갈때 까지 계속된다. 이 함수들은 일반적으로 수학에서의 함수와 매우 비슷하고 여기서는 일반적인 식의 형태로 정의할 것이다. 우리는 Turner의 언어 `Miranda`를 사용하지만 함수형 언어들에 대한 별 지식이 없어도 읽을 수 있다.

함수형 프로그래밍의 특별한 점과 이점은 자주 다음으로 요약된다. 함수형 프로그램은 변수 선언이 없고, 따라서 당연히 변수도 없고, 모든 값은 불변성을 가진다. 다시말해, 함수형 프로그램은 부작용이 없다. 함수 호출은 결과값을 계산하고 다른 것들에 아무 영향이 없다. 이것은 대부분의 버그의 원인을 차단하고, 또한 실행 순서를 중요하지 않게 만든다. 즉, 식의 값을 변경하는 부작용이 없으니 언제든지 계산되어도 괜찮다는 소리이다. 이건 코드 플로우에 머리가 터지는 프로그래머들에게 부담을 덜어준다. 식이 언제든지 계산될 수 있다는 것은 어떤 값이든 변수로 나타낼 수 있고, 그 반대도 가능하며, 이를 '참조적으로 투명하다'라고 한다. 이 자유로움은 다른 전통적인 언어보다 함수형 프로그램을 더 수학적으로 다룰 수 있게 해준다.

이 장점들은 모두 매우 훌륭하지만, 다른 사람들이 심각하게 받아들이지 않는다면 그렇게 놀랄만한 것들은 아니다. 이는 무엇이 함수형 프로그래밍이 아니냐(선언 X, 부작용 X, 코드 플로우 X)고는 알려주지만, 이게 뭔지는 알려주지 않는다. 함수형 프로그래머는 마치 고결해지기 위해 삶의 재미를 포기하는 수도승처럼 들린다. 물질적 이득에 관심이 있는 사람들에게는 이 장점들이 설득적이지 못한다.

함수형 프로그래머들은 굉장한 물질적 이득이 있다고 한다-함수형 프로그래머는 코드의 양이 적기 때문에 전통적인 언어보다 생산적이라고 한다. 왜 그래야 하나? 이러한 장점에 근거하여 낼 수 있는 유일한 그럴듯한 이유는 기존의 언어의 90%가 선언문으로 이루어져 있고 함수형 프로그램에선 이게 없기 때문이다! 이건 분명히 어이없다. 선언 문들을 없애는게 엄청난 혜택을 가져온다면 포트란 프로그래머는 20년전부터 그랬겠지. 기능을 뺌으로써 언어가 강력해지는건 말도 안된다. 그 기능이 얼마나 나쁜지와 관계 없이 말이다.

이 장점이라 불리는 것들에 함수형 프로그래머들은 만족하지 않아야 한다. 이는 함수형 언어를 활용하는데 전혀 도움이 되지 않기 때문이다. 선언 없이, 혹은 참조 투명하다는걸로는 프로그램을 작성할 수 없다. 거기에는 프로그램의 퀄리티를 따질 척도가 없고, 지향할 목표도 없다.

분명히 이 함수형 프로그래밍의 특징들로는 충분하지 않다. 우리는 여기에 넣을 뭔가를 찾아야 한다 - 함수형 프로그래밍의 힘을 설명하는 것만이 아닌것을, 하지만 또한 함수형 프로그래머가 무엇을 지향해야 할지 정확한 목표가 될 것을.

## 2. 구조적 프로그래밍의 비교

함수형이고 구조화된 프로그래밍을 비교하는 것은 도움이 된다. 과거에는, 구조적 프로그래밍의 특성과 장점은 다음으로 요약이 됬다. 구조적 프로그래밍은 `goto`문이 없다. 구조적 프로그램의 블록들은 여러개의 진입점이나 종료점이 없다. 구조적 프로그램들은 구조화되지 않은 기존의 프로그램들보다 수학적이다. 이 구조적 프로그래밍의 장점들은 우리가 좀전에 얘기했던 함수형 프로그래밍의 장점과 매우 닮아 있다. 이것들은 부정적인 것들이며 본질적인 `goto`과 관련된 무의미한 논쟁들만 가져온다.

되돌아보면, 이 구조적 프로그램의 속성들이 도움이 됬지만 문제의 핵심에는 별 도움을 주지 않는다. 가장 중요한 구조적 프로그램과 비구조적 프로그램의 차이는 구조적 프로그램은 모듈적 설계된다는 것이다. 모듈적 설계는 매우 생산적 발전을 가져온다. 가장 먼저, 작은 모듈은 빠르고 쉽게 코딩된다. 두번째로, 일반화된 모듈을 재사용될 수 있고 다음 프로그램을 빠르게 개발할 수 있다. 세번째로, 프로그램의 모듈은 독립적으로 테스트될 수 있어 디버깅 시간을 줄일 수 있다.

goto가 없는거랑 이거랑은 연관이 별로 없다. 이건 소규모 프로그래밍에 도움이 되고, 모듈  방식으로 디자인하는 건 대규모 프로그래밍에 도움이 된다. 그래서 누구나 조금만 작업을 해도 포트란이나 어셈블리어에서 구조적 프로그래밍을 하는 재미를 볼 수 있다.

모듈적 설계는 이제 성공적인 프로그래밍이 되는 키로 보통 인식되고, `Modula-II`나 `Ada`, 그리고 `Standard ML`같은 더 나은 모듈화를 돕도록 설계된 특별한 기능들을 포함하고 있다. 반면에, 가장 중요한 점 하나가 빠져 있다. 문제를 해결하러 모듈화된 프로그램을 작성할 때, 하나의 문제를 여러개의 문제로 나누고 나눠진 문제들을 해결한 다음 각 해결책을 하나로 합친다. 원래의 문제를 나누는 것은 해결책들을 다시 합치는 것에 달려 있다. 따라서, 문제를 잘 모듈화하여 각 능력을 높이려면, 프로그래밍 언어 차원에서 `접착제`를 제공해야 한다. 복잡한 스코프 규칙이나 분할 컴파일 방법은 저수준에만 도움이 되고 모듈화에 도움을 주는 툴을 제공하지 않는다.

이제 우리는 다시 함수형 프로그래밍으로 돌아와보자. 우리는 함수형 언어가 우리에게 제공하는 두가지, 매우 중요한 `접착제`에 대해 얘기해 볼 것이다. 우리는 매우 간단하고 쉽게 모듈화되는 많은 프로그램의 예제를 볼 것 이다. 이것이 함수형 프로그래밍의 강력함의 핵심이다 - 강력한 모듈화를 제공한다. 또한 이건 함수형 프로그래머가 지향해야 하는 목표이다 - 더 작고 더 간단한 많은 일반적인 모듈이 우리가 곧 설명할 `접착제`로 접착되는 것이다.

## 3. 함수 결합하기

간단한 함수를 서로 결합시켜서 더 복잡한 함수로 만들어주는 두 새로운 `접착제`의 첫번째이다. 이건 리스트에 원소를 더하는 간단한 리스트 처리 문제로 설명할 수 있다. 우리는 리스트를 다음과 같이 정의할 수 있다. (X는 특정한 기호가 아닌, *같은 의미)

```
listof X ::= nil | cons X (listof X)
```

리스트의 원소가 없을때인 X가 `nil`일 때이거나 다른 리스트에 X의 `cons`이다.  `cons`는 첫번째 원소가 X이고 나머지 원소들은 다른 원소들로 이루어진 리스트라고 할 수 있는 리스트를 나타낸다. 여기서의 X는 어떤 타입이든 될 수 있다. 예를 들어 X가 정수라면 이 정의는 정수의 리스트는 비어있는 리스트이거나 한 정수와 나머지 정수의 리스트의 `cons`이라는 것이다. 다음의 간단한 연습으로 우리는 리스트를 `nil`과 `cons`들로 일일히 쓰지 않고 대괄호로 원소들을 감싸서 간단하게 쓸것이다. 이건 노테이션의 편의를 위함일 뿐이다. 예를 들어,

```
[]			means nil
[1]			means cons 1 nil
[1,2,3]		means cons 1 (cons 2 (cons 3 nil))
```

리스트의 원소들은 재귀적 함수 `sum`으로 추가될 수 있다. `sum`은 두 종류의 매개변수로 정의되어야만 한다 : 빈 리스트 `nil`, 그리고 `cons`이다. 리스트가 비었을 때 합은 0이므로, 우리는 이를

```
sum nil = 0
```

로 정의하고, `cons`의 첫번째 원소와 나머지의 `sum`의 합으로 계산할 수 있으므로 우리는 이를

```
sum (cons num list) = num + sum list
```

로 정의할 수 있다.